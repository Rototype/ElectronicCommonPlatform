<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Inverter: Behavioral Architecture Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Inverter
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="class_inverter.html">Inverter</a></li><li class="navelem"><a class="el" href="class_inverter_1_1_behavioral.html">Behavioral</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#Signals">Signals</a> &#124;
<a href="#Processes">Processes</a>  </div>
  <div class="headertitle">
<div class="title">Behavioral Architecture Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The aim of the module is basically one: inverting the bits of the incoming image, but not all the bits, just the ones contained in the payload, not in the header (54 Bytes). To do this, the module firstly extracts the file dimension from the Header, by looking at its 3rd, 4th, 5th and 6th bytes, and inverting their order, since they are written in a Little Endian format. This means that the first byte that is present in the Header, in reality describes the LSBs of the file dimension. For example if we read 02-03-04-05, in reality the dimension is 05-04-03-02. This extrapolation process is shown in the following image:  
 <a href="class_inverter_1_1_behavioral.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="Processes"></a>
Processes</h2></td></tr>
 <tr class="memitem:a48c18f54ed5de7baebe70a74d847c00a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_inverter_1_1_behavioral.html#a48c18f54ed5de7baebe70a74d847c00a">Inversion</a>&#160;</td><td class="memItemRight" valign="bottom"><b> ( <b><b><a class="el" href="class_inverter.html#a70120f1e8cec2d88609e7ce3c4d8f941">clk</a></b> <span class="vhdlchar"> </span></b> , <b><b><a class="el" href="class_inverter.html#ab94494fc37d4189a4207f6d068d25cf7">resetn</a></b> <span class="vhdlchar"> </span></b> )</b></td></tr>
<tr class="memdesc:a48c18f54ed5de7baebe70a74d847c00a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This process is the responsible of inverting properly the image (we invert the image just after the Header, so from the 55th Byte on), resetting properly the <em>packet_counter</em> and generating the <em>out_tlast</em> and <em>out_tvalid</em>. Since everything has been described in the Architecture description section, here we make just a small reminder. First the process samples the incoming <em>in_tlast</em> and <em>in_tvalid</em> to generate the corresponding <em>out_tlast</em> and <em>out_tvalid</em>. Then when there is the handshake between <em>in_tvalid</em> and <em>in_tready</em> it extrapolates the file dimension from the header, and it inverts the image if <em>packet_counter</em> &gt; 52. (<em>packet_counter</em> increases by 4 at each handshake) Then the process manages the reset of <em>packet_counter</em>, if we recognize the falling edge of <em>in_tlast</em> we ask ourselves if it is the last "tlast" or not: if <em>packet_counter</em> and file dimension differs by a quantity lower than or equal to 3, it means that this is the last packet and so we reset <em>packet_counter</em>. Otherwise we do nothing. Notice that the comparison has been done among vectors (<em>image_length_vct</em> and <em>packet_counter_vct</em>) otherwise some confusion (if we would compare integers) will be created.  <a href="#a48c18f54ed5de7baebe70a74d847c00a"></a><br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="Signals"></a>
Signals</h2></td></tr>
 <tr class="memitem:a0e24189d7f8aa47747227cc39b5c5855"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_inverter_1_1_behavioral.html#a0e24189d7f8aa47747227cc39b5c5855">packet_counter_vct</a> &#160;</td><td class="memItemRight" valign="bottom"><b><span class="keywordtype">std_logic_vector</span><span class="vhdlchar"> </span><span class="vhdlchar">(</span><span class="vhdlchar"> </span><span class="vhdlchar"> </span> <span class="vhdldigit">31</span> <span class="vhdlchar"> </span><span class="keywordflow">downto</span><span class="vhdlchar"> </span><span class="vhdlchar"> </span> <span class="vhdldigit">0</span> <span class="vhdlchar"> </span><span class="vhdlchar">)</span><span class="vhdlchar"> </span><span class="vhdlchar"> </span><span class="vhdlchar">:</span><span class="vhdlchar">=</span><span class="vhdlchar"> </span><span class="vhdlchar">(</span><span class="vhdlchar"> </span><span class="vhdlchar"> </span><span class="keywordflow">others</span><span class="vhdlchar"> </span><span class="vhdlchar"> </span><span class="vhdlchar">=</span><span class="vhdlchar"> </span><span class="vhdlchar">&gt;</span><span class="vhdlchar"> </span><span class="vhdlchar">'</span><span class="vhdlchar"> </span> <span class="vhdldigit">0</span> <span class="vhdlchar"> </span><span class="vhdlchar">'</span><span class="vhdlchar"> </span><span class="vhdlchar">)</span><span class="vhdlchar"> </span></b></td></tr>
<tr class="memdesc:a0e24189d7f8aa47747227cc39b5c5855"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counter of the incoming packets*.  <a href="#a0e24189d7f8aa47747227cc39b5c5855"></a><br /></td></tr>
<tr class="memitem:a7fdde32b3efb0055a1fd0a34bb719886"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_inverter_1_1_behavioral.html#a7fdde32b3efb0055a1fd0a34bb719886">image_length_vct</a> &#160;</td><td class="memItemRight" valign="bottom"><b><span class="keywordtype">std_logic_vector</span><span class="vhdlchar"> </span><span class="vhdlchar">(</span><span class="vhdlchar"> </span><span class="vhdlchar"> </span> <span class="vhdldigit">31</span> <span class="vhdlchar"> </span><span class="keywordflow">downto</span><span class="vhdlchar"> </span><span class="vhdlchar"> </span> <span class="vhdldigit">0</span> <span class="vhdlchar"> </span><span class="vhdlchar">)</span><span class="vhdlchar"> </span><span class="vhdlchar"> </span><span class="vhdlchar">:</span><span class="vhdlchar">=</span><span class="vhdlchar"> </span><span class="vhdlchar">(</span><span class="vhdlchar"> </span><span class="vhdlchar"> </span><span class="keywordflow">others</span><span class="vhdlchar"> </span><span class="vhdlchar"> </span><span class="vhdlchar">=</span><span class="vhdlchar"> </span><span class="vhdlchar">&gt;</span><span class="vhdlchar"> </span><span class="vhdlchar">'</span><span class="vhdlchar"> </span> <span class="vhdldigit">0</span> <span class="vhdlchar"> </span><span class="vhdlchar">'</span><span class="vhdlchar"> </span><span class="vhdlchar">)</span><span class="vhdlchar"> </span></b></td></tr>
<tr class="memdesc:a7fdde32b3efb0055a1fd0a34bb719886"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector containing the file dimension (in Bytes) extrapolated from the Header at bit level. (Ex. 0x00110000)  <a href="#a7fdde32b3efb0055a1fd0a34bb719886"></a><br /></td></tr>
<tr class="memitem:a2e927fc498f96bc8fbe129b92fd1f6b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_inverter_1_1_behavioral.html#a2e927fc498f96bc8fbe129b92fd1f6b0">tlast_memory</a> &#160;</td><td class="memItemRight" valign="bottom"><b><span class="keywordtype">std_logic</span><span class="vhdlchar"> </span><span class="vhdlchar">:</span><span class="vhdlchar">=</span><span class="vhdlchar"> </span><span class="vhdlchar"> </span><span class="vhdlchar">'</span><span class="vhdlchar"> </span> <span class="vhdldigit">0</span> <span class="vhdlchar"> </span><span class="vhdlchar">'</span><span class="vhdlchar"> </span></b></td></tr>
<tr class="memdesc:a2e927fc498f96bc8fbe129b92fd1f6b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signal used to store temporarily the value of *in_tlast*, in order to recognize the falling edge of *in_tlast*.  <a href="#a2e927fc498f96bc8fbe129b92fd1f6b0"></a><br /></td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The aim of the module is basically one: inverting the bits of the incoming image, but not all the bits, just the ones contained in the payload, not in the header (54 Bytes). To do this, the module firstly extracts the file dimension from the Header, by looking at its 3rd, 4th, 5th and 6th bytes, and inverting their order, since they are written in a Little Endian format. This means that the first byte that is present in the Header, in reality describes the LSBs of the file dimension. For example if we read 02-03-04-05, in reality the dimension is 05-04-03-02. This extrapolation process is shown in the following image: </p>
<div class="image">
<object type="image/svg+xml" data="Data.svg" style="pointer-events: none;"></object>
<div class="caption">
[File dimension]</div></div>
<p> If we go deeper in this process, we have to add that since for each packet we receive 4 Bytes, and the file dimension is present at the bytes 3rd-4th-5th-6th, they come across two different packets, the 3rd and 4th are within the first packet of the header, while the 5th and 6th on the second packet of the header. So in reality the process is the following: </p><div class="image">
<object type="image/svg+xml" data="Data_detailed.svg" style="pointer-events: none;"></object>
<div class="caption">
[File dimension detailed]</div></div>
<p> In particular the file dimension will be exploited when we have to reset to 0 the value of <em>packet_counter</em> (for the sake of clarity, in the code the signal that has been used is <em>packet_counter_vct</em>, which is a vector of bits). When that signal reaches the file dimension, it means that we have finished and so we reset <em>packet_counter</em> for being ready to accept other images. Then the module depending on the value of <em>packet_counter</em>, which counts the number of incoming packets, inverts (if <em>packet_counter</em> &gt; 54) the incoming data or let them pass unchanged (if <em>packet_counter</em> &lt;= 54) </p><div class="image">
<object type="image/svg+xml" data="Inversion.svg" style="pointer-events: none;"></object>
<div class="caption">
[Image Inversion]</div></div>
<p> In reality, since we receive the packets iin blocks of 4 Bytes, the <em>packet_counter</em> increases by 4 at each handshake, and so since 54 is not a multiple of 4, we have to find the 54th Bytes when <em>packet_counter</em> is 52. Indeed: </p><div class="image">
<object type="image/svg+xml" data="52packets.svg" style="pointer-events: none;"></object>
<div class="caption">
[Image Inversion detailed]</div></div>
<p> The last thing that this module does, is understanding when the image processing is finished and consequently when resetting to 0 the value of <em>packet_counter</em>. The first thing that has been done in order to do this, is recognizing the falling edge of the <em>in_tlast</em> signal coming from the DMA. The DMA sends a <em>in_tlast</em> at the end of each packet sent via Software (SW). Let's better explain this concept. Via SW we can decide how many packets per transfer we can send: </p><div class="image">
<img src="SW_Transfer.PNG" alt=""/>
<div class="caption">
[File transfer]</div></div>
<p> Every NUM_INT_SENT Bytes a <em>in_tlast</em> signal will be sent, so depending on the dimension of the overall file, we need 1 or more transfer cycles, so 1 or more <em>in_tlast</em> signals. But we want to reset the <em>packet_counter</em> just in corrispondence of the last <em>in_tlast</em>. In reality it is not true that the <em>in_tlast</em> is generated every NUM_INT_SENT Bytes, because it can happen that the last transfer will include less than NUM_INT_SENT bytes and this is the case of a file dimension which is not a multiple of NUM_INT_SENT. However this control is made by the SW, which decides how large is the transfer, and the <em>in_tlast</em> is in any case generated at the end of the transfer, whatever is the dimension of the transfer. For example if we have a 16MB file, the SW sends 4MB- 4MB- 4MB- 4MB and the <em>in_tlast</em> goes high at the 16Mth byte. Instead if we have a file of 14 MB, the SW sends 4MB- 4MB- 4MB- 2MB, and the <em>in_tlast</em> goes high at the 14M th byte. This is to say that for understanding which is the last <em>in_tlast</em> in order to reset <em>packet_counter</em> to 0, is enough to compare <em>packet_counter</em> and file dimension every time a falling edge of <em>in_tlast</em> is detected, and the last <em>in_tlast</em> is just when they are equal, which means that the packet counter has reached the overall file dimension. </p><div class="image">
<img src="SW_Transfer_last.PNG" alt=""/>
<div class="caption">
[Last file transfer]</div></div>
 <div class="image">
<object type="image/svg+xml" data="Last_packet.svg" style="pointer-events: none;"></object>
<div class="caption">
[Last packet transfer]</div></div>
<p> In reality, since we receive 4 packets per time (32 bits), it can happen that the last packet is within the last packet, for example in the 3rd Byte. So the condition that tells us if we have finished, is if <em>image_length</em> minus <em>packet_counter</em> is lower than or equal to 3, then the last packet is contained here and so we reset the <em>packet_counter</em>. In the following image we can see a better explanation: </p><div class="image">
<object type="image/svg+xml" data="Last_packet_detailed.svg" style="pointer-events: none;"></object>
<div class="caption">
[Last packet transfer detailed]</div></div>
<p> Indeed if we take as an example the case of <em>image_length</em> = 100/99/98/97, <em>packet_counter</em>, once we detect the falling edge of <em>in_tlast</em>, will have the value of 100 (see ILA waveform), and so in order to understand if we have to reset the counter, we make the difference between <em>packet_counter</em> and <em>image_length</em>. If it is the last <em>in_tlast</em> the only thing that could happen is that <em>image_length</em> has a value at least larger than <em>packet_counter</em> - 3. </p><div class="image">
<img src="ILA_Wave.PNG" alt=""/>
<div class="caption">
[ILA Waveform]</div></div>
<p> In practice, on the ILA we see that once we reach the last packet (17M), the number of packets contained in the last one are 16999997/16999998/16999999/17M (remember that input and inverted are shifted by 1 clock cycle, so for example in case of <em>packet_counter = 4</em> you see as inverted output the input that were present with <em>packet_counter = 0</em>). So since file dimension is 17M we have to reset. The <em>packet_counter</em> and the <em>inverted_tdata</em> are reset to '0' also when the <em>resetn</em> is active. Then in addition to the process <em>Inversion</em>, we have a small part in Dataflow, where we send directly in output <em>in_tready</em> and we generate the ports <em>counter</em> and <em>file_dimension</em> in case of <em>DEBUG_MODE = TRUE</em>. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a48c18f54ed5de7baebe70a74d847c00a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48c18f54ed5de7baebe70a74d847c00a">&#9670;&nbsp;</a></span>Inversion()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> <b><span class="vhdlchar"> </span></b> Inversion</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><b><b><a class="el" href="class_inverter.html#a70120f1e8cec2d88609e7ce3c4d8f941">clk</a></b> <span class="vhdlchar"> </span></b> <em></em> , </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><b><b><a class="el" href="class_inverter.html#ab94494fc37d4189a4207f6d068d25cf7">resetn</a></b> <span class="vhdlchar"> </span></b> <em></em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">Process</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This process is the responsible of inverting properly the image (we invert the image just after the Header, so from the 55th Byte on), resetting properly the <em>packet_counter</em> and generating the <em>out_tlast</em> and <em>out_tvalid</em>. Since everything has been described in the Architecture description section, here we make just a small reminder. First the process samples the incoming <em>in_tlast</em> and <em>in_tvalid</em> to generate the corresponding <em>out_tlast</em> and <em>out_tvalid</em>. Then when there is the handshake between <em>in_tvalid</em> and <em>in_tready</em> it extrapolates the file dimension from the header, and it inverts the image if <em>packet_counter</em> &gt; 52. (<em>packet_counter</em> increases by 4 at each handshake) Then the process manages the reset of <em>packet_counter</em>, if we recognize the falling edge of <em>in_tlast</em> we ask ourselves if it is the last "tlast" or not: if <em>packet_counter</em> and file dimension differs by a quantity lower than or equal to 3, it means that this is the last packet and so we reset <em>packet_counter</em>. Otherwise we do nothing. Notice that the comparison has been done among vectors (<em>image_length_vct</em> and <em>packet_counter_vct</em>) otherwise some confusion (if we would compare integers) will be created. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a7fdde32b3efb0055a1fd0a34bb719886"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fdde32b3efb0055a1fd0a34bb719886">&#9670;&nbsp;</a></span>image_length_vct</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_inverter_1_1_behavioral.html#a7fdde32b3efb0055a1fd0a34bb719886">image_length_vct</a> <b><span class="keywordtype">std_logic_vector</span><span class="vhdlchar"> </span><span class="vhdlchar">(</span><span class="vhdlchar"> </span><span class="vhdlchar"> </span> <span class="vhdldigit">31</span> <span class="vhdlchar"> </span><span class="keywordflow">downto</span><span class="vhdlchar"> </span><span class="vhdlchar"> </span> <span class="vhdldigit">0</span> <span class="vhdlchar"> </span><span class="vhdlchar">)</span><span class="vhdlchar"> </span><span class="vhdlchar"> </span><span class="vhdlchar">:</span><span class="vhdlchar">=</span><span class="vhdlchar"> </span><span class="vhdlchar">(</span><span class="vhdlchar"> </span><span class="vhdlchar"> </span><span class="keywordflow">others</span><span class="vhdlchar"> </span><span class="vhdlchar"> </span><span class="vhdlchar">=</span><span class="vhdlchar"> </span><span class="vhdlchar">&gt;</span><span class="vhdlchar"> </span><span class="vhdlchar">'</span><span class="vhdlchar"> </span> <span class="vhdldigit">0</span> <span class="vhdlchar"> </span><span class="vhdlchar">'</span><span class="vhdlchar"> </span><span class="vhdlchar">)</span><span class="vhdlchar"> </span></b> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">Signal</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector containing the file dimension (in Bytes) extrapolated from the Header at bit level. (Ex. 0x00110000) </p>

</div>
</div>
<a id="a0e24189d7f8aa47747227cc39b5c5855"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e24189d7f8aa47747227cc39b5c5855">&#9670;&nbsp;</a></span>packet_counter_vct</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_inverter_1_1_behavioral.html#a0e24189d7f8aa47747227cc39b5c5855">packet_counter_vct</a> <b><span class="keywordtype">std_logic_vector</span><span class="vhdlchar"> </span><span class="vhdlchar">(</span><span class="vhdlchar"> </span><span class="vhdlchar"> </span> <span class="vhdldigit">31</span> <span class="vhdlchar"> </span><span class="keywordflow">downto</span><span class="vhdlchar"> </span><span class="vhdlchar"> </span> <span class="vhdldigit">0</span> <span class="vhdlchar"> </span><span class="vhdlchar">)</span><span class="vhdlchar"> </span><span class="vhdlchar"> </span><span class="vhdlchar">:</span><span class="vhdlchar">=</span><span class="vhdlchar"> </span><span class="vhdlchar">(</span><span class="vhdlchar"> </span><span class="vhdlchar"> </span><span class="keywordflow">others</span><span class="vhdlchar"> </span><span class="vhdlchar"> </span><span class="vhdlchar">=</span><span class="vhdlchar"> </span><span class="vhdlchar">&gt;</span><span class="vhdlchar"> </span><span class="vhdlchar">'</span><span class="vhdlchar"> </span> <span class="vhdldigit">0</span> <span class="vhdlchar"> </span><span class="vhdlchar">'</span><span class="vhdlchar"> </span><span class="vhdlchar">)</span><span class="vhdlchar"> </span></b> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">Signal</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Counter of the incoming packets*. </p>

</div>
</div>
<a id="a2e927fc498f96bc8fbe129b92fd1f6b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e927fc498f96bc8fbe129b92fd1f6b0">&#9670;&nbsp;</a></span>tlast_memory</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_inverter_1_1_behavioral.html#a2e927fc498f96bc8fbe129b92fd1f6b0">tlast_memory</a> <b><span class="keywordtype">std_logic</span><span class="vhdlchar"> </span><span class="vhdlchar">:</span><span class="vhdlchar">=</span><span class="vhdlchar"> </span><span class="vhdlchar"> </span><span class="vhdlchar">'</span><span class="vhdlchar"> </span> <span class="vhdldigit">0</span> <span class="vhdlchar"> </span><span class="vhdlchar">'</span><span class="vhdlchar"> </span></b> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">Signal</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Signal used to store temporarily the value of *in_tlast*, in order to recognize the falling edge of *in_tlast*. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>D:/MW/MW/Utility_Ip_Core/ip_repo/AXI4Stream_Inverter/hdl/<a class="el" href="_inverter_8vhd.html">Inverter.vhd</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.20
</small></address>
</body>
</html>

----------------------------------------------------------------------------------
-- Company: 
-- Engineer: 
-- 
-- Create Date: 26.09.2019 17:49:23
-- Design Name: 
-- Module Name: SM_ctrl - rtl
-- Project Name: 
-- Target Devices: 
-- Tool Versions: 
-- Description: 
-- 
-- Dependencies: 
-- 
-- Revision:
-- Revision 0.01 - File Created
-- Additional Comments:
-- 
----------------------------------------------------------------------------------


library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.STD_LOGIC_UNSIGNED.ALL;
use IEEE.NUMERIC_STD.ALL;

library UNISIM;
use UNISIM.vcomponents.all;

library std;
use std.textio.all;

entity SM_ctrl_real is
  Port ( 
        aclk        : in    std_logic;
        aresetn     : in    std_logic;
		--
        clk200      : in    std_logic;                      -- synchronous respect to aclk
        --      		
		tgt_ACC		: in	std_logic_vector(23 downto 0);  -- unsigned
		tgt_EC		: in	std_logic_vector(21 downto 0);  -- unsigned  
		dir			: in	std_logic;                      -- 0 = clockwise, 1 = counterclockwise; 
		ena_load    : in	std_logic_vector(1 downto 0);   -- "0x" = free; "10" = 100%, "11" = 50%  down to engine control (port_ena, port_load)
		res			: in	std_logic_vector(1 downto 0);   -- port M2p M1p  
		init_EC	    : in	std_logic_vector(21 downto 0);  -- (step-in speed) unsigned
		cnt_o		: in	std_logic_vector(31 downto 0);  -- tgt_cnt
		cnt_i		: out	std_logic_vector(31 downto 0);  -- curr_cnt
		--
		ramp_up		: in	std_logic;                      -- from still to tgt_EC with tgt_ACC; (test if curr_EC < tgt_EC)
		ramp_dwn	: in	std_logic;                      -- from curr_EC to still with tgt_ACC (test if curr_EC > init_EC) 
		spd_chg		: in	std_logic;                      -- from curr_EC to tgt_EC with tgt_ACC (verify if ACCelerate or DECelerate)
		--
		slw_stps	: in	std_logic;                      -- execution of tgt_cnt steps at init_EC
		--
		fst_stps	: in	std_logic;                      -- execution of tgt_cnt steps from still to tgt_EC and then down to still, using tgt_ACC
		--
		running		: out	std_logic;
		--
		irq_mask	: in	std_logic;
		irq_in		: out	std_logic;
		irq_clr		: in	std_logic;
		vld_in		: out	std_logic;
		vld_out		: in	std_logic;
		--
		port_ref	: out	std_logic;
		port_clk    : out	std_logic;
		port_ena	: out	std_logic;
		port_dir	: out	std_logic;
		port_m2P	: out	std_logic;
		port_m1P	: out	std_logic	      				   
    );
end SM_ctrl_real;

architecture rtl of SM_ctrl_real is

constant EC_init_int         : natural     := 2_500_000;
constant ACC_init_int        : natural     :=   214_243;    -- 2_097_151 is top acceleration

constant Pulse_len_greater_tW  : natural   := 50;      -- debug only
-- constant Pulse_len_greater_tW  : natural   := 2_200;      -- tW is the minimum pulse len admitted by SM controller.

------- reset tree resampling  -------------------------------------------------------
signal aresetn_loc                        : std_logic := '1'; 
signal resetn                             : std_logic := '0';    
signal reset                              : std_logic := '1'; 

------- (EC, ACC) -> NEXT_EC engine --------------------------------------------------

signal EC_cnt            : std_logic_vector(21 downto 0) := std_logic_vector(TO_UNSIGNED(1, 22));
signal Next_EC_loc       : STD_LOGIC_VECTOR(21 DOWNTO 0) := (others => '0');
signal Next_RM_loc       : STD_LOGIC_VECTOR(15 DOWNTO 0) := (others => '0');

signal pulse_cnt         : std_logic_vector(15 downto 0) := (others => '0');        
signal clock_loc         : std_logic := '0';

signal steps_ena         : std_logic := '0';
signal steps             : std_logic_vector(31 downto 0) := (others => '0');
signal acc_flg           : std_logic := '0';
signal acc_steps         : std_logic_vector(31 downto 0) := (others => '0');
signal dec_steps         : std_logic_vector(31 downto 0) := (others => '0');
signal steps_vld         : std_logic := '0';

----------

signal end_trj_reg		 : std_logic_vector(31 downto 0);
signal end_trj_trig_msb  : std_logic := '0';
signal end_trj_trig_lsb  : std_logic := '0';
signal end_trj_trig      : std_logic := '0';

signal mid_trj_reg		 : std_logic_vector(31 downto 0);
signal mid_trj_trig_msb  : std_logic := '0';
signal mid_trj_trig_lsb  : std_logic := '0';
signal mid_trj_trig      : std_logic := '0';

signal dec_trj_trig_msb  : std_logic := '0';
signal dec_trj_trig_lsb  : std_logic := '0';
signal dec_trj_trig      : std_logic := '0';

signal EC_tgt_trig       : std_logic;

signal fst_stps_d1       : std_logic := '0';
signal fst_stps_d2       : std_logic := '0';
signal fst_stps_trig     : std_logic := '0';

signal slw_stps_d1       : std_logic := '0';
signal slw_stps_d2       : std_logic := '0';
signal slw_stps_trig     : std_logic := '0';

signal ramp_up_d1       : std_logic := '0';
signal ramp_up_d2       : std_logic := '0';
signal ramp_up_trig     : std_logic := '0';

signal ramp_dwn_d1       : std_logic := '0';
signal ramp_dwn_d2       : std_logic := '0';
signal ramp_dwn_trig     : std_logic := '0';

signal spd_chg_d1       : std_logic := '0';
signal spd_chg_d2       : std_logic := '0';
signal spd_chg_trig     : std_logic := '0';

----------
signal stp_cnt_vld_in    : std_logic;
signal stp_cnt           : std_logic_vector(31 downto 0);
signal stp_cnt_lsb       : std_logic_vector(15 downto 0);
signal stp_cnt_vld       : std_logic;

----------
type state_type is (still,
                    --
                    stp_in,     stp_in_w,
                    accelerate, accelerate_w,
                    steady,     steady_w,
                    steady_o,   steady_o_w,
                    last,       last_w,
                    decelerate, decelerate_w,
                    step_out,   step_out_w,
                    --
                    slw_stp_in, slw_stp_in_w,
                    slw_stp_out,slw_stp_out_w,
                    --
                    recovery);
                    
signal sm_state          : state_type;
signal triangle          : std_logic := '0';  --1 triangle, 0=trapezoid
signal sm_start          : std_logic := '0';
signal sm_stop           : std_logic := '0';

signal sm_run_stp        : std_logic := '0';
signal sm_run_spd        : std_logic := '0';

signal sm_vld            : std_logic := '0';
signal sm_nxt_EC_loc     : STD_LOGIC_VECTOR(21 DOWNTO 0);  -- Next EndCount  unsigned, local
signal sm_nxt_RM_loc     : STD_LOGIC_VECTOR(15 DOWNTO 0);  -- Next ReMainder unsigned, local
signal sm_ACC_pos        : STD_LOGIC_VECTOR(21 DOWNTO 0);  -- signed
signal sm_ACC_neg        : STD_LOGIC_VECTOR(21 DOWNTO 0);  -- signed
-- these signal will became IO to the stepper algorithm server
signal sm_ACC            : STD_LOGIC_VECTOR(21 DOWNTO 0);  -- signed     
signal sm_EC             : std_logic_vector(21 downto 0);  -- EndCount, unsigned
signal sm_RM             : STD_LOGIC_VECTOR(15 DOWNTO 0);  -- ReMainder unsigned 
signal sm_nxt_EC         : STD_LOGIC_VECTOR(21 DOWNTO 0);  -- Next EndCount  unsigned
signal sm_nxt_RM         : STD_LOGIC_VECTOR(15 DOWNTO 0);  -- Next ReMainder unsigned 
signal sm_req            : std_logic := '0';
signal sm_pend           : std_logic := '0';
signal sm_ack            : std_logic := '0';
--
signal spd_updn_cnt      : std_logic_vector(31 downto 0);  -- updwn counter of algorithm execution. UP when acc pos and /=0, DN when acc neg (and /= 0)
signal ACC_sign_flg      : std_logic := '0';
signal ACC_zero_flg      : std_logic := '1';
signal spd_updn_trig     : std_logic := '1';

component next_ec_engine is
  Port ( 
        -- clk & reset
        aresetn     : in    std_logic;
        aclk        : in    std_logic;
        clk200      : in    std_logic;  -- synchronous respect to aclk
        -- Parameters
        ACC         : in    STD_LOGIC_VECTOR(21 DOWNTO 0);  -- signed        
        -- Status in       
        EC          : in    STD_LOGIC_VECTOR(21 DOWNTO 0);  -- EndCount, unsigned
        RM          : in    STD_LOGIC_VECTOR(15 DOWNTO 0);  -- ReMainder unsigned  
        vld_in      : in	std_logic;
        -- Status out
        Next_EC     : out   STD_LOGIC_VECTOR(21 DOWNTO 0);  -- Next EndCount  unsigned
        Next_RM     : out   STD_LOGIC_VECTOR(15 DOWNTO 0);  -- Next ReMainder unsigned
        valid_out   : out   STD_LOGIC      				   
    );
end component next_ec_engine;

begin

------- reset trees resampling  ----------------------------

    rst_gen: process (aclk)
    begin       
       if rising_edge(aclk) then
         aresetn_loc <= aresetn;
         resetn      <= aresetn_loc;
         reset       <= not(aresetn_loc);      
       end if;
    end process rst_gen; 

    
------- (EC, ACC) -> NEXT_EC engine --------------------------------------------------  
-- this function has to be placed outside and shared among 5 (better 10) different customers.

nxt_ec : next_ec_engine
  Port map ( 
        -- clk & reset
        aresetn     => aresetn,
        aclk        => aclk,     
        clk200      => clk200,      
        -- Parameters  
        ACC         => sm_ACC,         
        -- Status in
        EC          => sm_EC,
        RM          => sm_RM,              
        vld_in      => sm_req,      
        -- Status out -- Status ou
        Next_EC     => sm_nxt_EC,
        Next_RM     => sm_nxt_RM,           
        valid_out   => sm_ack   
    );

-------------------------------------------------------------------------------------
   
    Step_registers: process (aclk)    
    begin       
       if rising_edge(aclk) then
         if (reset = '1') then
            end_trj_reg     <= (others => '0');
            mid_trj_reg     <= (others => '0');
         else
            end_trj_reg <= cnt_o - x"1";
            mid_trj_reg <= ('0' & cnt_o(31 downto 1)) - x"2";  -- even
         end if;                                                                
       end if;
    end process Step_registers; 
      
 
    end_trj_trigger: process (clk200)
    begin       
       if rising_edge(clk200) then
        if (reset = '1') then
            end_trj_trig_msb  <= '0';
            end_trj_trig_lsb  <= '0';
            end_trj_trig      <= '0';   
        else
            if (sm_run_stp = '1') then
                if (sm_start = '1') then
                    if (steps(15 downto 0) =  end_trj_reg(15 downto 0)) then
                        end_trj_trig_lsb <= '1';
                    else
                        end_trj_trig_lsb <= '0';                
                    end if;
                    if (steps(31 downto 16) =  end_trj_reg(31 downto 16)) then
                        end_trj_trig_msb <= '1';
                    else
                        end_trj_trig_msb <= '0';                
                    end if;                
                end if;
                end_trj_trig <= end_trj_trig_msb and end_trj_trig_lsb;
            else
                end_trj_trig_msb  <= '0';
                end_trj_trig_lsb  <= '0';
                end_trj_trig      <= '0'; 
            end if; 
        end if;                                                                
       end if;
    end process end_trj_trigger; 

    mid_trj_trigger: process (clk200)
    begin       
       if rising_edge(clk200) then
        if (reset = '1') then
            mid_trj_trig_msb  <= '0';
            mid_trj_trig_lsb  <= '0';
            mid_trj_trig      <= '0';   
        else
            if (sm_run_stp = '1') then
                if (sm_start = '1') then
                    if (steps(15 downto 0) =  mid_trj_reg(15 downto 0)) then
                        mid_trj_trig_lsb <= '1';
                    else
                        mid_trj_trig_lsb <= '0';                
                    end if;
                    if (steps(31 downto 16) =  mid_trj_reg(31 downto 16)) then
                        mid_trj_trig_msb <= '1';
                    else
                        mid_trj_trig_msb <= '0';                
                    end if;                
                end if;
                mid_trj_trig <= mid_trj_trig_msb and mid_trj_trig_lsb;
            else
                mid_trj_trig_msb  <= '0';
                mid_trj_trig_lsb  <= '0';
                mid_trj_trig      <= '0';   
            end if; 
        end if;                                                                
       end if;
    end process mid_trj_trigger; 

    dec_trj_trigger: process (clk200)
    begin       
       if rising_edge(clk200) then
        if (reset = '1') then
            dec_trj_trig_msb  <= '0';
            dec_trj_trig_lsb  <= '0';
            dec_trj_trig      <= '0';   
        else
            if (sm_run_stp = '1') then
                if (sm_start = '1') then
                    if (steps(15 downto 0) =  dec_steps(15 downto 0)) then
                        dec_trj_trig_lsb <= '1';
                    else
                        dec_trj_trig_lsb <= '0';                
                    end if;
                    if (steps(31 downto 16) =  dec_steps(31 downto 16)) then
                        dec_trj_trig_msb <= '1';
                    else
                        dec_trj_trig_msb <= '0';                
                    end if;                
                end if;
                dec_trj_trig <= dec_trj_trig_msb and dec_trj_trig_lsb;
            else
                dec_trj_trig_msb  <= '0';
                dec_trj_trig_lsb  <= '0';
                dec_trj_trig      <= '0';   
            end if; 
        end if;                                                                
       end if;
    end process dec_trj_trigger; 

    EC_tgt_trigger: process (clk200)
    begin       
       if rising_edge(clk200) then
        if (reset = '1') then
            EC_tgt_trig      <= '0';   
        else
            if (sm_run_stp = '1') then
                if (sm_start = '1') then
                    if not((sm_EC  >  tgt_EC)) then
                        EC_tgt_trig <= '1';
                    else
                        EC_tgt_trig <= '0';                
                    end if;           
                end if;
            else
                EC_tgt_trig      <= '0';
            end if;                
        end if;                                                                
       end if;
    end process EC_tgt_trigger;  
    
    fst_stps_trigger: process (clk200)
    begin       
       if rising_edge(clk200) then
         if (reset = '1') then
            fst_stps_d1       <= '0';
            fst_stps_d2       <= '0';
            fst_stps_trig     <= '0';   
         else
            fst_stps_d1       <= fst_stps;   
            fst_stps_d2       <= fst_stps_d1;
            if (fst_stps_d1 = '1') and (fst_stps_d2 = '0') then
                fst_stps_trig     <= '1';
            else
                fst_stps_trig     <= '0';
            end if;                             
         end if;                                                                
       end if;
    end process fst_stps_trigger;  
    
    slw_stps_trigger: process (clk200)
    begin       
       if rising_edge(clk200) then
         if (reset = '1') then
            slw_stps_d1       <= '0';
            slw_stps_d2       <= '0';
            slw_stps_trig     <= '0';   
         else
            slw_stps_d1       <= slw_stps;   
            slw_stps_d2       <= slw_stps_d1;
            if (slw_stps_d1 = '1') and (slw_stps_d2 = '0') then
                slw_stps_trig     <= '1';
            else
                slw_stps_trig     <= '0';
            end if;                             
         end if;                                                                
       end if;
    end process slw_stps_trigger;
    
    ramp_up_trigger: process (clk200)
    begin       
       if rising_edge(clk200) then
         if (reset = '1') then
            ramp_up_d1       <= '0';
            ramp_up_d2       <= '0';
            ramp_up_trig     <= '0';   
         else
            ramp_up_d1       <= ramp_up;   
            ramp_up_d2       <= ramp_up_d1;
            if (ramp_up_d1 = '1') and (ramp_up_d2 = '0') then
                ramp_up_trig     <= '1';
            else
                ramp_up_trig     <= '0';
            end if;                             
         end if;                                                                
       end if;
    end process ramp_up_trigger; 
      
    ramp_dwn_trigger: process (clk200)
    begin       
       if rising_edge(clk200) then
         if (reset = '1') then
            ramp_dwn_d1       <= '0';
            ramp_dwn_d2       <= '0';
            ramp_dwn_trig     <= '0';   
         else
            ramp_dwn_d1       <= ramp_up;   
            ramp_dwn_d2       <= ramp_up_d1;
            if (ramp_dwn_d1 = '1') and (ramp_dwn_d2 = '0') then
                ramp_dwn_trig     <= '1';
            else
                ramp_dwn_trig     <= '0';
            end if;                             
         end if;                                                                
       end if;
    end process ramp_dwn_trigger; 
      
    spd_chg_trigger: process (clk200)
    begin       
       if rising_edge(clk200) then
         if (reset = '1') then
            spd_chg_d1       <= '0';
            spd_chg_d2       <= '0';
            spd_chg_trig     <= '0';   
         else
            spd_chg_d1       <= spd_chg;   
            spd_chg_d2       <= spd_chg_d1;
            if (spd_chg_d1 = '1') and (spd_chg_d2 = '0') then
                spd_chg_trig     <= '1';
            else
                spd_chg_trig     <= '0';
            end if;                             
         end if;                                                                
       end if;
    end process spd_chg_trigger; 
      
  -----------------------------------------------------------------------------
    
    sm_ACC_pos  <= tgt_ACC(21 downto 0);
    sm_ACC_neg  <= not(sm_ACC_pos) + X"1";
    
    sm_fsm: process (clk200)
    begin       
        if rising_edge(clk200) then
            if (reset = '1') then        
                sm_state   <= still;
                triangle   <= '0';  --1 triangle, 0=trapezoid
                steps      <= (others => '0');
                acc_flg    <= '0';
                acc_steps  <= (others => '0');
                dec_steps  <= (others => '0');                
                sm_start   <= '0';
                sm_stop    <= '0';
                sm_ACC     <= (others => '0');
                EC_cnt     <= std_logic_vector(TO_UNSIGNED(1, 22));
                pulse_cnt  <= (others => '0'); 
                clock_loc  <= '0';     
                --     
                steps_vld  <= '0';
                sm_run_stp <= '0'; 
                sm_run_spd <= '0';
                
                -- these signals will became outputs
                sm_req     <= '0';
                sm_EC      <= (others => '0');
                sm_RM      <= (others => '0');
                -- these signals will became inputs qualified by "sm_ack"          
                sm_nxt_EC_loc  <= (others => '1');
                sm_nxt_RM_loc  <= (others => '0');
                --
                cnt_i          <= (others => '0'); 
            else
            
                -- trapezoid vs triangle detector
                if (sm_run_stp = '1') then
                    if (mid_trj_trig = '1') and (sm_stop = '1') then
                        if (EC_tgt_trig = '1') then
                            triangle   <= '0';  -- at midway the steady state has been reached, so trapezoid                                
                        else
                            triangle   <= '1';  -- at midway the steady state has NOT been reached, so triangle
                        end if;
                    end if;  
                end if;
                
                 -- steps counter
                if (sm_state = accelerate_w) then
                    acc_flg <= '1';
                else
                    acc_flg <= '0';
                end if;     
                if (fst_stps_trig = '1') or (slw_stps_trig = '1') then
                    steps      <= std_logic_vector(TO_UNSIGNED(1, 32));
                elsif (sm_run_stp = '1') then     
                    if (sm_stop = '1') then
                        if (EC_tgt_trig = '1') and (acc_flg = '1') then
                            acc_steps <= steps;
                            dec_steps <= end_trj_reg - steps;
                        end if;
                        steps      <= steps + X"1";                  
                    end if;
                else
                    steps     <= (others => '0');
                    acc_steps <= (others => '0');
                    dec_steps <= (others => '0');              
                end if;

                -- PWM counter
                if (sm_run_stp = '1') then 
                    if (sm_start = '1') then
                        EC_cnt <= std_logic_vector(TO_UNSIGNED(4, 22));
                        sm_stop    <= '0';
--                    elsif (EC_cnt = sm_EC) then  -- up to Endcount
                    elsif (EC_cnt = 100) then  -- Only for simulation                 
                        EC_cnt <= std_logic_vector(TO_UNSIGNED(1, 22));
                        sm_stop    <= '1';
                    else
                        EC_cnt <= EC_cnt + X"1";
                        sm_stop    <= '0';
                    end if;
                else
                    EC_cnt <= std_logic_vector(TO_UNSIGNED(1, 22));
                    sm_stop    <= '0';
                end if;
                
                -- clock pulse width counter
                if (pulse_cnt = 0) then
                    if (sm_start = '1') then
                        pulse_cnt <= pulse_cnt + "01";
                        clock_loc <= '1';
                    else
                        pulse_cnt <= (others => '0');
                        clock_loc <= '0';
                    end if;
                elsif (pulse_cnt = Pulse_len_greater_tW) then
                    pulse_cnt <= (others => '0');
                    clock_loc <= '0';
                else
                    pulse_cnt <= pulse_cnt + "01";
                    clock_loc <= '1';
                end if;                
                 
                -- Next_EC qualifier.
                if (sm_run_stp = '1') then
                    if (sm_ack = '1') then
                        sm_nxt_EC_loc  <= sm_nxt_EC;
                        sm_nxt_RM_loc  <= sm_nxt_RM;
                    end if;        
                else
                    sm_nxt_EC_loc  <= (others => '1');
                    sm_nxt_RM_loc  <= (others => '0');
                end if;                              
                                                        
                -- Stepper Motor FSM
                case (sm_state) is
                    when still =>
                        sm_start <= '0';
                        triangle   <= '0';  --1 triangle, 0=trapezoid
                        sm_ACC   <= (others => '0');                        
                        sm_EC    <= (others => '0');
                        sm_RM    <= (others => '0');   
                        if (slw_stps_trig = '1') then
                            sm_state   <= slw_stp_in;
                            sm_run_stp <= '1';
                        elsif (fst_stps_trig = '1') then
                            sm_state <= stp_in;
                            sm_run_stp <= '1';                         
                        else
                            sm_state <= still;
                            sm_run_stp <= '0';                          
                        end if;
                        sm_run_spd <= '0';
                                                                           
                    when stp_in =>
                        sm_state <= stp_in_w;
                        sm_start <= '1';
                        sm_req   <= '1';
                        sm_ACC   <= sm_ACC_pos;                        
                        sm_EC    <= init_EC;         -- step_in
                        sm_RM    <= (others => '0');                           
                    when stp_in_w =>
                        sm_start <= '0';
                        sm_req   <= '0';
                        if (sm_stop = '1') then                                                                                           
                            sm_state <= accelerate;
                        else
                            sm_state <= stp_in_w;
                        end if;
                                                                        
                    when accelerate =>
                        sm_state <= accelerate_w;
                        sm_start <= '1';
                        sm_req   <= '1';                                                  
                        sm_ACC   <= sm_ACC_pos;                        
                        sm_EC    <= sm_nxt_EC_loc;
                        sm_RM    <= sm_nxt_RM_loc;                                                                            
                   when accelerate_w =>
                        sm_start <= '0';
                        sm_req   <= '0';                        
                        if (sm_stop = '1') then                                                                                                                                    
                            if ((triangle = '1') or (EC_tgt_trig = '1')) then 
                                if (cnt_o(0) = '0') then  -- even steps
                                    sm_state <= steady;
                                else
                                    sm_state <= steady_o; -- odd steps                                   
                                end if;
                            else
                                sm_state <= accelerate;
                            end if;                            
                        else
                            sm_state <= accelerate_w;                        
                        end if;
 
                    when steady_o =>                    -- extra steady state, used when cnt_o is odd.
                        sm_state <= steady_o_w;
                        sm_start <= '1';
                        sm_req   <= '0';                         
                        sm_ACC   <= (others => '0');                        
                        sm_EC    <= sm_EC;
                        sm_RM    <= (others => '0');                                                     
                    when steady_o_w =>
                        sm_start <= '0';
                        sm_req   <= '0'; 
                        if (sm_stop = '1') then 
                            sm_state <= steady;                                
                        else
                            sm_state <= steady_o_w;   
                        end if;
                                                
                    when steady =>
                        sm_state <= steady_w;
                        sm_start <= '1';
                        sm_req   <= '0';                         
                        sm_ACC   <= (others => '0');                        
                        sm_EC    <= sm_EC;
                        sm_RM    <= (others => '0');                                                     
                    when steady_w =>
                        sm_start <= '0';
                        sm_req   <= '0'; 
                        if (sm_stop = '1') then 
                            if ((triangle = '1') or (dec_trj_trig = '1')) then                                
                                sm_state <= last;
                            else
                                sm_state <= steady;
                            end if;                                
                        else
                            sm_state <= steady_w;   
                        end if;
 
                     when last =>
                        sm_state <= last_w;
                        sm_start <= '1';
                        sm_req   <= '1';                         
                        sm_ACC   <= sm_ACC_neg;                        
                        sm_EC    <= sm_EC;
                        sm_RM    <= (others => '0');                                                     
                    when last_w =>
                        sm_start <= '0';
                        sm_req   <= '0';
                        sm_req   <= '0'; 
                        if (sm_stop = '1') then                            
                            sm_state <= decelerate;
                        else
                            sm_state <= last_w;   
                        end if;
                                                
                    when decelerate => 
                        sm_state <= decelerate_w;
                        sm_start <= '1';
                        sm_req   <= '1';                                                  
                        sm_ACC   <= sm_ACC_neg;                        
                        sm_EC    <= sm_nxt_EC_loc;
                        sm_RM    <= sm_nxt_RM_loc;                                                     
                    when decelerate_w =>
                        sm_start <= '0';
                        sm_req   <= '0';                        
                        if (sm_stop = '1') then 
                            if (end_trj_trig = '1') then                                                                
                                sm_state <= step_out;
                            else
                                sm_state <= decelerate;
                            end if;
                        else
                            sm_state <= decelerate_w;   
                        end if;
                                               
                    when step_out =>
                        sm_state <= step_out_w;
                        sm_start <= '1';
                        sm_req   <= '0';                                                                     
                        sm_ACC   <= (others => '0');                      
                        sm_EC    <= init_EC;         -- step_out
                        sm_RM    <= (others => '0');                         
                    when step_out_w => 
                        sm_start <= '0';
                        sm_req   <= '0';                                                                   
                        if (sm_stop = '1') then                                                                 
                            sm_state    <= still;
                            sm_run_stp  <= '0';                            
                        else
                            sm_state    <= step_out_w;
                            sm_run_stp  <= '1';    
                        end if;
                        
                    -----------------------------    
                    when slw_stp_in =>
                        sm_state <= slw_stp_in_w;
                        sm_start <= '1';
                        sm_req   <= '0';                                                                     
                        sm_ACC   <= (others => '0');                      
                        sm_EC    <= init_EC;         -- step_out
                        sm_RM    <= (others => '0');                         
                    when slw_stp_in_w => 
                        sm_start <= '0';
                        sm_req   <= '0';                                                                   
                        if (sm_stop = '1') then                                                                 
                            if (end_trj_trig = '1') then                                                                
                                sm_state <= slw_stp_out;
                            else
                                sm_state <= slw_stp_in;
                            end if;
                        else
                            sm_state <= slw_stp_in_w;
                        end if;
                                               
                    when slw_stp_out =>
                       sm_state <= slw_stp_out_w;
                       sm_start <= '1';
                       sm_req   <= '0';                                                                     
                       sm_ACC   <= (others => '0');                      
                       sm_EC    <= init_EC;         -- step_out
                       sm_RM    <= (others => '0');                         
                    when slw_stp_out_w => 
                       sm_start <= '0';
                       sm_req   <= '0';                                                                   
                       if (sm_stop = '1') then                                                                 
                           sm_state   <= still;
                           sm_run_stp <= '0';                            
                       else
                           sm_state   <= slw_stp_out_w;
                           sm_run_stp <= '1';    
                       end if;
                                                   
                    -----------------------------  
                    when recovery =>
                        sm_state     <= still;
                        sm_run_stp   <= '0'; 
                    
                    when others =>                                            
                        sm_state <= recovery;
                end case;
                
                -- Variables to processor
                cnt_i    <= steps;
                running  <= sm_run_stp or sm_run_spd;                                                    
            end if;
        end if;
    end process sm_fsm;          




       

-- synthesis translate_off
         
    print_values :process(reset, sm_start)
    variable line_var : line;
    file text_var : text;

    begin
        if (falling_edge(reset)) then
            file_open(text_var,".\SM_EC_RM_vhdl_write.txt", write_mode);
        END IF;
        
        if (falling_edge(sm_start)) then
            write(line_var, integer'image(to_integer(unsigned(sm_EC))));
            -- write(line_var, integer'image(to_integer(unsigned(Next_RM))));
            writeline(text_var, line_var);   -- write line_var into the file
        end if;
             
        -- file_close(text_var);
    end process print_values;

-- synthesis translate_on    
    
    port_ref <=  sm_ack;
    port_clk <=  clock_loc;
    port_ena <=  sm_nxt_EC(20) xor
                 sm_nxt_EC(19) xor
                 sm_nxt_EC(18) xor
                 sm_nxt_EC(17) xor
                 sm_nxt_EC(16) xor
                 sm_nxt_EC(15) xor
                 sm_nxt_EC(14) xor
                 sm_nxt_EC(13) xor
                 sm_nxt_EC(12) xor
                 sm_nxt_EC(11) xor
                 sm_nxt_EC(10) xor
                 sm_nxt_EC( 9) xor
                 sm_nxt_EC( 8) xor
                 sm_nxt_EC( 7) xor
                 sm_nxt_EC( 6) xor
                 sm_nxt_EC( 5) xor
                 sm_nxt_EC( 4) xor
                 sm_nxt_EC( 3) xor
                 sm_nxt_EC( 2) xor
                 sm_nxt_EC( 1) xor
                 sm_nxt_EC( 0); 
                    
    port_dir <= steps(31);  
	port_m2P <= end_trj_trig xor mid_trj_trig xor EC_tgt_trig;
---------------------------------------------------------------------------

--		port_ref	<= '0';
--		port_clk	<= '0';
--		port_ena	<= '0';
--		port_dir	<= '0';
--		port_m2P	<= '0';
		port_m1P	<= '0';
		
		
		
		

end rtl;

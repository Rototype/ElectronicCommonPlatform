----------------------------------------------------------------------------------
-- Company: 
-- Engineer: 
-- 
-- Create Date: 26.09.2019 17:49:23
-- Design Name: 
-- Module Name: SM_ctrl - rtl
-- Project Name: 
-- Target Devices: 
-- Tool Versions: 
-- Description: 
-- 
-- Dependencies: 
-- 
-- Revision:
-- Revision 0.01 - File Created
-- Additional Comments:
-- 
----------------------------------------------------------------------------------


library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.STD_LOGIC_UNSIGNED.ALL;
use IEEE.NUMERIC_STD.ALL;

library UNISIM;
use UNISIM.vcomponents.all;

entity SM_ctrl_real is
  Port ( 
        aclk        : in    std_logic;
        aresetn     : in    std_logic;
		--
        clk200      : in    std_logic;  -- synchronous respect to aclk
        --		
		max_acc		: in	std_logic_vector(23 downto 0);
		tgt_spd		: in	std_logic_vector(17 downto 0);
		dir			: in	std_logic;
		load		: in	std_logic;
		res			: in	std_logic_vector(1 downto 0);
		init_spd	: in	std_logic_vector(9 downto 0);
		cnt_o		: in	std_logic_vector(31 downto 0);
		cnt_i		: out	std_logic_vector(31 downto 0);
		ramp_up		: in	std_logic;
		ramp_dwn	: in	std_logic;
		spd_chg		: in	std_logic;
		slw_stps	: in	std_logic;
		fst_stps	: in	std_logic;
		running		: out	std_logic;
		irq_mask	: in	std_logic;
		irq_in		: out	std_logic;
		irq_clr		: in	std_logic;
		vld_in		: out	std_logic;
		vld_out		: in	std_logic;
		--
		port_ref	: out	std_logic;
		port_clk    : out	std_logic;
		port_ena	: out	std_logic;
		port_dir	: out	std_logic;
		port_m2P	: out	std_logic;
		port_m1P	: out	std_logic	      				   
    );
end SM_ctrl_real;

architecture rtl of SM_ctrl_real is

constant FCLK_int            : natural     := 200_000_000; -- MHz Not used, only a reminder
constant FCLK                : std_logic_vector(27 downto 0) := std_logic_vector(TO_UNSIGNED(FCLK_int, 28));
constant EC_init_int         : natural     := 2_500_000;
constant ACC_init_int        : natural     := 2_097_151;    -- 2_097_151 is top acceleration

------- reset tree resampling  -------------------------------------------------------
signal aresetn_loc                        : std_logic := '1'; 
signal resetn                             : std_logic := '0';    
signal reset                              : std_logic := '1'; 

------- (EC, ACC) -> NEXT_EC engine --------------------------------------------------

signal EC_init_u22                        : STD_LOGIC_VECTOR(21 DOWNTO 0) := std_logic_vector(TO_UNSIGNED(EC_init_int, 22));

signal new_ec_cnt_dbg                     : std_logic_vector(15 downto 0);

signal EC_vld                             : std_logic := '0';
signal EC_dly_cnt                         : std_logic_vector(7 downto 0);
                                                  
signal ACC_s22                            : STD_LOGIC_VECTOR(21 DOWNTO 0) := std_logic_vector(TO_SIGNED(ACC_init_int, 22));

signal EC_u22                             : STD_LOGIC_VECTOR(21 DOWNTO 0);

COMPONENT mult_u22_u22  -- lat5
  PORT (
    CLK  : IN STD_LOGIC;
    SCLR : IN STD_LOGIC;
    A    : IN STD_LOGIC_VECTOR(21 DOWNTO 0);
    B    : IN STD_LOGIC_VECTOR(21 DOWNTO 0);
    P    : OUT STD_LOGIC_VECTOR(42 DOWNTO 0)
  );
END COMPONENT;

signal ECxEC_u43                          : STD_LOGIC_VECTOR(42 downto 0);

---------

COMPONENT mult_s22_10995 --lat5
  PORT (
    CLK  : IN STD_LOGIC;
    SCLR : IN STD_LOGIC;    
    A    : IN STD_LOGIC_VECTOR(21 DOWNTO 0);
    P    : OUT STD_LOGIC_VECTOR(35 DOWNTO 0)
  );
END COMPONENT;

signal ACCx2elv41_dvFclk_s36              : STD_LOGIC_VECTOR(35 DOWNTO 0);
signal ACCx10995_s36                      : STD_LOGIC_VECTOR(35 DOWNTO 0);

---------

COMPONENT mult_s36_u43_lat7 --lat 8
  PORT (
    CLK  : IN STD_LOGIC;
    SCLR : IN STD_LOGIC;
    A    : IN STD_LOGIC_VECTOR(35 DOWNTO 0);
    B    : IN STD_LOGIC_VECTOR(42 DOWNTO 0);
    P    : OUT STD_LOGIC_VECTOR(36 DOWNTO 0)   -- yet divided by 2^41
  );
END COMPONENT;

signal ACCx10995xECxEC_dv2exp41_s37      : STD_LOGIC_VECTOR(36 DOWNTO 0); 

---------

COMPONENT add_s36_fclk_lat3
  PORT (
    CLK  : IN STD_LOGIC;
    SCLR : IN STD_LOGIC;
    A    : IN STD_LOGIC_VECTOR(36 DOWNTO 0);    
    S    : OUT STD_LOGIC_VECTOR(36 DOWNTO 0)
  );
END COMPONENT;

signal Fclk_ACCx10995xECxEC_dv2exp41_s37  : STD_LOGIC_VECTOR(36 DOWNTO 0);
signal Fclk_ACCx10995xECxEC_dv2exp41_u36  : STD_LOGIC_VECTOR(35 DOWNTO 0);
---------

COMPONENT mult_u22_fclk  --lat4
  PORT (
    CLK  : IN STD_LOGIC;
    SCLR : IN STD_LOGIC;    
    A    : IN STD_LOGIC_VECTOR(21 DOWNTO 0);
    P    : OUT STD_LOGIC_VECTOR(49 DOWNTO 0)
  );
END COMPONENT;

---------

signal ECxFclk_s50                        : STD_LOGIC_VECTOR(49 DOWNTO 0);
signal Fclk_ACCx10995xECxEC_dv2exp41_s40  : STD_LOGIC_VECTOR(39 DOWNTO 0);

COMPONENT div_s50_s36_lat34
  PORT (
    aclk                    : IN STD_LOGIC;
    aresetn                 : IN STD_LOGIC;
    --
    s_axis_dividend_tvalid  : IN STD_LOGIC;
    s_axis_dividend_tready  : OUT STD_LOGIC;
    s_axis_dividend_tdata   : IN STD_LOGIC_VECTOR(55 DOWNTO 0);
    --
    s_axis_divisor_tvalid   : IN STD_LOGIC;
    s_axis_divisor_tready   : OUT STD_LOGIC;
    s_axis_divisor_tdata    : IN STD_LOGIC_VECTOR(39 DOWNTO 0);
    --
    m_axis_dout_tvalid      : OUT STD_LOGIC;
    m_axis_dout_tdata       : OUT STD_LOGIC_VECTOR(55 DOWNTO 0)
  );
END COMPONENT;

signal ECxFclk_s56                        : STD_LOGIC_VECTOR(55 DOWNTO 0);


signal Next_EC_s56                        : STD_LOGIC_VECTOR(55 DOWNTO 0);
signal Next_EC_u56                        : STD_LOGIC_VECTOR(55 DOWNTO 0);  
signal Next_EC_in_tvalid                  : STD_LOGIC;
signal Next_EC_s56_tvalid                 : STD_LOGIC;
signal Next_EC_tvalid                     : STD_LOGIC;
signal Next_EC_tvalid_dly                 : STD_LOGIC_VECTOR(7 DOWNTO 0); 
signal Next_EC_dividend_tready            : STD_LOGIC; 
signal Next_EC_divisor_tready             : STD_LOGIC;

signal Next_EC_u22                        : STD_LOGIC_VECTOR(21 DOWNTO 0);  
signal Next_EC_vld                        : STD_LOGIC; 

signal Next_EC_aresetn                    : STD_LOGIC := '1'; 

begin

------- reset trees resampling  ----------------------------

    rst_gen: process (aclk)
    begin       
       if rising_edge(aclk) then
         aresetn_loc <= aresetn;
         resetn      <= aresetn_loc;
         reset       <= not(aresetn_loc);      
       end if;
    end process rst_gen; 

    
------- (EC, ACC) -> NEXT_EC engine --------------------------------------------------   

    EC_gen_dbg: process (clk200)
    begin       
       if rising_edge(clk200) then
        if (reset = '1') then
            new_ec_cnt_dbg      <= X"0000";
            EC_vld              <= '0';
            Next_EC_tvalid_dly  <= X"00";
            Next_EC_in_tvalid   <= '0';  
            
            ACC_s22 <= (others => '0');
            EC_u22  <= (others => '0');    
        else
        
            if (new_ec_cnt_dbg = 150) then
                new_ec_cnt_dbg <= X"0000";
            else
                new_ec_cnt_dbg <= new_ec_cnt_dbg + '1';
            end if;
            
            if (new_ec_cnt_dbg = 1) then
                EC_vld    <= '1';
                ACC_s22   <= std_logic_vector(TO_SIGNED(ACC_init_int, 22));
                EC_u22    <= Next_EC_u22;                                       -- !!! Here is feedback
            else
                EC_vld  <= '0';
            end if;
            
            if (Next_EC_tvalid_dly = 0) then
                Next_EC_in_tvalid   <= '0'; 
                if (EC_vld = '1') then
                   Next_EC_tvalid_dly <= Next_EC_tvalid_dly + '1';
                end if;
            elsif (Next_EC_tvalid_dly = 16) then
                Next_EC_in_tvalid   <= '1';                
                Next_EC_tvalid_dly  <= x"00";
            else
                Next_EC_in_tvalid   <= '0';                                                 
                Next_EC_tvalid_dly  <= Next_EC_tvalid_dly + '1';
            end if;
         end if;                                                                
       end if;
    end process EC_gen_dbg; 

------- NEXT_EC dividend --------------------------------------------------

    FCLKxEC: mult_u22_fclk  --lat4
      PORT MAP (
        CLK  => clk200,
        SCLR => reset,  
        A    => EC_u22,
        P    => ECxFclk_s50
      );
      
------- NEXT_EC divisor --------------------------------------------------

    ECxEC : mult_u22_u22
      PORT MAP(
        CLK  => clk200,
        SCLR => reset,
        A    => EC_u22,
        B    => EC_u22,
        P    => ECxEC_u43
      );
     
    ACCx2elv41_dvFclk: mult_s22_10995 --lat5
      PORT MAP(
        CLK  => clk200,
        SCLR => reset,
        A    => ACC_s22,
        P    => ACCx2elv41_dvFclk_s36
      );

    ACCx10995_s36 <= ACCx2elv41_dvFclk_s36;
    
    ACCx10995xECxEC_dv2exp41: mult_s36_u43_lat7 --lat 8
      PORT MAP(
        CLK  => clk200,
        SCLR => reset,
        A    => ACCx10995_s36,
        B    => ECxEC_u43,
        P    => ACCx10995xECxEC_dv2exp41_s37
      );

    Fclk_ACCx10995xECxEC_dv2exp41: add_s36_fclk_lat3
      PORT MAP(
        CLK  => clk200,
        SCLR => reset,
        A    => ACCx10995xECxEC_dv2exp41_s37,   
        S    => Fclk_ACCx10995xECxEC_dv2exp41_s37
      );

    Fclk_ACCx10995xECxEC_dv2exp41_u36 <= Fclk_ACCx10995xECxEC_dv2exp41_s37(35 downto 0);  --result is positive by definition

------- NEXT_EC division --------------------------------------------------

    -- byte alignment, required by axis. resources are s50/s37 
    ECxFclk_s56                       <= "000000" & ECxFclk_s50;
    Fclk_ACCx10995xECxEC_dv2exp41_s40 <= "000" & Fclk_ACCx10995xECxEC_dv2exp41_s37;
    
    Next_EC_aresetn <= resetn or EC_vld;
    
    NEXT_EC: div_s50_s36_lat34
      PORT MAP(
        aclk                    => clk200,
        aresetn                 => resetn,
        --
        s_axis_dividend_tvalid  => Next_EC_in_tvalid,
        s_axis_dividend_tready  => Next_EC_dividend_tready,
        s_axis_dividend_tdata   => ECxFclk_s56,
        --
        s_axis_divisor_tvalid   => Next_EC_in_tvalid,
        s_axis_divisor_tready   => Next_EC_divisor_tready,
        s_axis_divisor_tdata    => Fclk_ACCx10995xECxEC_dv2exp41_s40,
        --
        m_axis_dout_tvalid      => Next_EC_s56_tvalid,
        m_axis_dout_tdata       => Next_EC_s56
      );

    Next_EC_store: process (clk200)
    begin       
       if rising_edge(clk200) then
         if (reset = '1') then
            Next_EC_u22         <= EC_init_u22; 
            Next_EC_vld         <= '0';    
         else
            Next_EC_vld         <= Next_EC_s56_tvalid;
            if (Next_EC_s56_tvalid = '1') then
                Next_EC_u22     <= Next_EC_s56(21 downto 0);
            end if;
         end if;                                                                
       end if;
    end process Next_EC_store; 
    
    
    port_ref <=  Next_EC_vld;
    port_clk <=  Next_EC_u22(21) xor
                 Next_EC_u22(20) xor
                 Next_EC_u22(19) xor
                 Next_EC_u22(18) xor
                 Next_EC_u22(17) xor
                 Next_EC_u22(16) xor
                 Next_EC_u22(15) xor
                 Next_EC_u22(14) xor
                 Next_EC_u22(13) xor
                 Next_EC_u22(12) xor
                 Next_EC_u22(11) xor
                 Next_EC_u22(10) xor
                 Next_EC_u22( 9) xor
                 Next_EC_u22( 8) xor
                 Next_EC_u22( 7) xor
                 Next_EC_u22( 6) xor
                 Next_EC_u22( 5) xor
                 Next_EC_u22( 4) xor
                 Next_EC_u22( 3) xor
                 Next_EC_u22( 2) xor
                 Next_EC_u22( 1) xor
                 Next_EC_u22( 0);    
    

---------------------------------------------------------------------------

--		port_ref	<= '0';
--		port_clk	<= '0';
		port_ena	<= '0';
		port_dir	<= '0';
		port_m2P	<= '0';
		port_m1P	<= '0';
		
		
		
		

end rtl;
